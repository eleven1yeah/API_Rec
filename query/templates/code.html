<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>code</title>
</head>
<body>
<pre style="word-wrap: break-word; white-space: pre-wrap;">/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "megastruct_types.h"

#include &lt;algorithm&gt;
#include &lt;ostream&gt;

#include &lt;thrift/TToString.h&gt;



int _kMyEnumValues[] = {
  MyEnum::LLAMA,
  MyEnum::ALPACA
};
const char* _kMyEnumNames[] = {
  "LLAMA",
  "ALPACA"
};
const std::map&lt;int, const char*&gt; _MyEnum_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kMyEnumValues, _kMyEnumNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


MiniStruct::~MiniStruct() throw() {
}


void MiniStruct::__set_my_string(const std::string&amp; val) {
  this-&gt;my_string = val;
__isset.my_string = true;
}

void MiniStruct::__set_my_enum(const MyEnum::type val) {
  this-&gt;my_enum = val;
__isset.my_enum = true;
}

uint32_t MiniStruct::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot-&gt;readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot-&gt;readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot-&gt;readString(this-&gt;my_string);
          this-&gt;__isset.my_string = true;
        } else {
          xfer += iprot-&gt;skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot-&gt;readI32(ecast0);
          this-&gt;my_enum = (MyEnum::type)ecast0;
          this-&gt;__isset.my_enum = true;
        } else {
          xfer += iprot-&gt;skip(ftype);
        }
        break;
      default:
        xfer += iprot-&gt;skip(ftype);
        break;
    }
    xfer += iprot-&gt;readFieldEnd();
  }

  xfer += iprot-&gt;readStructEnd();

  return xfer;
}

uint32_t MiniStruct::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot-&gt;writeStructBegin("MiniStruct");

  if (this-&gt;__isset.my_string) {
    xfer += oprot-&gt;writeFieldBegin("my_string", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot-&gt;writeString(this-&gt;my_string);
    xfer += oprot-&gt;writeFieldEnd();
  }
  if (this-&gt;__isset.my_enum) {
    xfer += oprot-&gt;writeFieldBegin("my_enum", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot-&gt;writeI32((int32_t)this-&gt;my_enum);
    xfer += oprot-&gt;writeFieldEnd();
  }
  xfer += oprot-&gt;writeFieldStop();
  xfer += oprot-&gt;writeStructEnd();
  return xfer;
}

void swap(MiniStruct &amp;a, MiniStruct &amp;b) {
  using ::std::swap;
  swap(a.my_string, b.my_string);
  swap(a.my_enum, b.my_enum);
  swap(a.__isset, b.__isset);
}

MiniStruct::MiniStruct(const MiniStruct&amp; other1) {
  my_string = other1.my_string;
  my_enum = other1.my_enum;
  __isset = other1.__isset;
}
MiniStruct&amp; MiniStruct::operator=(const MiniStruct&amp; other2) {
  my_string = other2.my_string;
  my_enum = other2.my_enum;
  __isset = other2.__isset;
  return *this;
}
void MiniStruct::printTo(std::ostream&amp; out) const {
  using ::apache::thrift::to_string;
  out &lt;&lt; "MiniStruct(";
  out &lt;&lt; "my_string="; (__isset.my_string ? (out &lt;&lt; to_string(my_string)) : (out &lt;&lt; "&lt;null&gt;"));
  out &lt;&lt; ", " &lt;&lt; "my_enum="; (__isset.my_enum ? (out &lt;&lt; to_string(my_enum)) : (out &lt;&lt; "&lt;null&gt;"));
  out &lt;&lt; ")";
}


MegaStruct::~MegaStruct() throw() {
}


void MegaStruct::__set_my_bool(const bool val) {
  this-&gt;my_bool = val;
__isset.my_bool = true;
}

void MegaStruct::__set_my_byte(const int8_t val) {
  this-&gt;my_byte = val;
__isset.my_byte = true;
}

void MegaStruct::__set_my_16bit_int(const int16_t val) {
  this-&gt;my_16bit_int = val;
__isset.my_16bit_int = true;
}

void MegaStruct::__set_my_32bit_int(const int32_t val) {
  this-&gt;my_32bit_int = val;
__isset.my_32bit_int = true;
}

void MegaStruct::__set_my_64bit_int(const int64_t val) {
  this-&gt;my_64bit_int = val;
__isset.my_64bit_int = true;
}

void MegaStruct::__set_my_double(const double val) {
  this-&gt;my_double = val;
__isset.my_double = true;
}

void MegaStruct::__set_my_string(const std::string&amp; val) {
  this-&gt;my_string = val;
__isset.my_string = true;
}

void MegaStruct::__set_my_binary(const std::string&amp; val) {
  this-&gt;my_binary = val;
__isset.my_binary = true;
}

void MegaStruct::__set_my_string_string_map(const std::map&lt;std::string, std::string&gt; &amp; val) {
  this-&gt;my_string_string_map = val;
__isset.my_string_string_map = true;
}

void MegaStruct::__set_my_string_enum_map(const std::map&lt;std::string, MyEnum::type&gt; &amp; val) {
  this-&gt;my_string_enum_map = val;
__isset.my_string_enum_map = true;
}

void MegaStruct::__set_my_enum_string_map(const std::map&lt;MyEnum::type, std::string&gt; &amp; val) {
  this-&gt;my_enum_string_map = val;
__isset.my_enum_string_map = true;
}

void MegaStruct::__set_my_enum_struct_map(const std::map&lt;MyEnum::type, MiniStruct&gt; &amp; val) {
  this-&gt;my_enum_struct_map = val;
__isset.my_enum_struct_map = true;
}

void MegaStruct::__set_my_enum_stringlist_map(const std::map&lt;MyEnum::type, std::vector&lt;std::string&gt; &gt; &amp; val) {
  this-&gt;my_enum_stringlist_map = val;
__isset.my_enum_stringlist_map = true;
}

void MegaStruct::__set_my_enum_structlist_map(const std::map&lt;MyEnum::type, std::vector&lt;MiniStruct&gt; &gt; &amp; val) {
  this-&gt;my_enum_structlist_map = val;
__isset.my_enum_structlist_map = true;
}

void MegaStruct::__set_my_stringlist(const std::vector&lt;std::string&gt; &amp; val) {
  this-&gt;my_stringlist = val;
__isset.my_stringlist = true;
}

void MegaStruct::__set_my_structlist(const std::vector&lt;MiniStruct&gt; &amp; val) {
  this-&gt;my_structlist = val;
__isset.my_structlist = true;
}

void MegaStruct::__set_my_enumlist(const std::vector&lt;MyEnum::type&gt; &amp; val) {
  this-&gt;my_enumlist = val;
__isset.my_enumlist = true;
}

void MegaStruct::__set_my_stringset(const std::set&lt;std::string&gt; &amp; val) {
  this-&gt;my_stringset = val;
__isset.my_stringset = true;
}

void MegaStruct::__set_my_enumset(const std::set&lt;MyEnum::type&gt; &amp; val) {
  this-&gt;my_enumset = val;
__isset.my_enumset = true;
}

void MegaStruct::__set_my_structset(const std::set&lt;MiniStruct&gt; &amp; val) {
  this-&gt;my_structset = val;
__isset.my_structset = true;
}

uint32_t MegaStruct::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot-&gt;readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot-&gt;readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {

</pre>
</body>
</html>